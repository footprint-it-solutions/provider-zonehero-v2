// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
)

type HeroLoadBalancerListenerAttachmentInitParameters struct {

	// The Application-Layer Protocol Negotiation (ALPN) policy to use. Valid values:
	//
	// * `HTTP1Only` - Only allow HTTP/1.* connections
	// * `HTTP2Only` - Only allow HTTP/2 connections
	// * `HTTP2Optional` - Prefer HTTP/1.*, but allow HTTP/2 if client supports it
	// * `HTTP2Preferred` - Prefer HTTP/2, but allow HTTP/1.* if client doesn't support HTTP/2
	// * `None` - Do not use ALPN
	AlpnPolicy *string `json:"alpnPolicy,omitempty" tf:"alpn_policy,omitempty"`

	// The name of the secret in AWS Secrets Manager containing the SSL server certificate. This field is required if the protocol is HTTPS. The secret should contain the certificate and private key in PEM format.
	CertificateSecretsName *string `json:"certificateSecretsName,omitempty" tf:"certificate_secrets_name,omitempty"`

	// If true, deletion of the listener will be disabled via the API. This prevents accidental deletion of production listeners. You must set this to false and apply the change before you can delete the listener.
	EnableDeletionProtection *bool `json:"enableDeletionProtection,omitempty" tf:"enable_deletion_protection,omitempty"`

	// The ID of the HLB load balancer to attach this listener to. This cannot be changed once the listener is created - you must create a new listener to move it to a different load balancer.
	LoadBalancerID *string `json:"loadBalancerId,omitempty" tf:"load_balancer_id,omitempty"`

	// When the load balancer `enable_cross_zone_load_balancing` is set to `avoid` (default), this factor determines how much traffic a single instance can receive relative to the average. For example, with a value of `1.1`, an instance can receive up to 110% of the average traffic. This helps optimize resource usage while maintaining zone isolation. Must be greater than or equal to 1.0. Applies to the target group - behavior is undefined if different values are assigned to different listeners with the same target group.
	OverprovisioningFactor *float64 `json:"overprovisioningFactor,omitempty" tf:"overprovisioning_factor,omitempty"`

	// The port on which the load balancer is listening. Must be between 1 and 65535. Common ports:
	//
	// * 80 - HTTP
	// * 443 - HTTPS
	//
	// Note: The security groups associated with the load balancer must allow inbound traffic on this port.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The protocol for connections from clients to the load balancer. Valid values:
	//
	// * `HTTP` - For unencrypted HTTP traffic
	// * `HTTPS` - For encrypted HTTPS traffic. When using HTTPS, you must also specify a `certificate_secrets_name`
	//
	// * `UDP` - For raw unencrypted UDP traffic
	//
	// The protocol cannot be changed after the listener is created - you must create a new listener to change protocols.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The Amazon Resource Name (ARN) of the target group to route traffic to. The target group defines where traffic will be sent (the backend instances, IP addresses, or other resources) and how health checks are performed. The target group must be in the same region as the load balancer.
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`
}

type HeroLoadBalancerListenerAttachmentObservation struct {

	// The Application-Layer Protocol Negotiation (ALPN) policy to use. Valid values:
	//
	// * `HTTP1Only` - Only allow HTTP/1.* connections
	// * `HTTP2Only` - Only allow HTTP/2 connections
	// * `HTTP2Optional` - Prefer HTTP/1.*, but allow HTTP/2 if client supports it
	// * `HTTP2Preferred` - Prefer HTTP/2, but allow HTTP/1.* if client doesn't support HTTP/2
	// * `None` - Do not use ALPN
	AlpnPolicy *string `json:"alpnPolicy,omitempty" tf:"alpn_policy,omitempty"`

	// The name of the secret in AWS Secrets Manager containing the SSL server certificate. This field is required if the protocol is HTTPS. The secret should contain the certificate and private key in PEM format.
	CertificateSecretsName *string `json:"certificateSecretsName,omitempty" tf:"certificate_secrets_name,omitempty"`

	// If true, deletion of the listener will be disabled via the API. This prevents accidental deletion of production listeners. You must set this to false and apply the change before you can delete the listener.
	EnableDeletionProtection *bool `json:"enableDeletionProtection,omitempty" tf:"enable_deletion_protection,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The ID of the HLB load balancer to attach this listener to. This cannot be changed once the listener is created - you must create a new listener to move it to a different load balancer.
	LoadBalancerID *string `json:"loadBalancerId,omitempty" tf:"load_balancer_id,omitempty"`

	// When the load balancer `enable_cross_zone_load_balancing` is set to `avoid` (default), this factor determines how much traffic a single instance can receive relative to the average. For example, with a value of `1.1`, an instance can receive up to 110% of the average traffic. This helps optimize resource usage while maintaining zone isolation. Must be greater than or equal to 1.0. Applies to the target group - behavior is undefined if different values are assigned to different listeners with the same target group.
	OverprovisioningFactor *float64 `json:"overprovisioningFactor,omitempty" tf:"overprovisioning_factor,omitempty"`

	// The port on which the load balancer is listening. Must be between 1 and 65535. Common ports:
	//
	// * 80 - HTTP
	// * 443 - HTTPS
	//
	// Note: The security groups associated with the load balancer must allow inbound traffic on this port.
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The protocol for connections from clients to the load balancer. Valid values:
	//
	// * `HTTP` - For unencrypted HTTP traffic
	// * `HTTPS` - For encrypted HTTPS traffic. When using HTTPS, you must also specify a `certificate_secrets_name`
	//
	// * `UDP` - For raw unencrypted UDP traffic
	//
	// The protocol cannot be changed after the listener is created - you must create a new listener to change protocols.
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The Amazon Resource Name (ARN) of the target group to route traffic to. The target group defines where traffic will be sent (the backend instances, IP addresses, or other resources) and how health checks are performed. The target group must be in the same region as the load balancer.
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`
}

type HeroLoadBalancerListenerAttachmentParameters struct {

	// The Application-Layer Protocol Negotiation (ALPN) policy to use. Valid values:
	//
	// * `HTTP1Only` - Only allow HTTP/1.* connections
	// * `HTTP2Only` - Only allow HTTP/2 connections
	// * `HTTP2Optional` - Prefer HTTP/1.*, but allow HTTP/2 if client supports it
	// * `HTTP2Preferred` - Prefer HTTP/2, but allow HTTP/1.* if client doesn't support HTTP/2
	// * `None` - Do not use ALPN
	// +kubebuilder:validation:Optional
	AlpnPolicy *string `json:"alpnPolicy,omitempty" tf:"alpn_policy,omitempty"`

	// The name of the secret in AWS Secrets Manager containing the SSL server certificate. This field is required if the protocol is HTTPS. The secret should contain the certificate and private key in PEM format.
	// +kubebuilder:validation:Optional
	CertificateSecretsName *string `json:"certificateSecretsName,omitempty" tf:"certificate_secrets_name,omitempty"`

	// If true, deletion of the listener will be disabled via the API. This prevents accidental deletion of production listeners. You must set this to false and apply the change before you can delete the listener.
	// +kubebuilder:validation:Optional
	EnableDeletionProtection *bool `json:"enableDeletionProtection,omitempty" tf:"enable_deletion_protection,omitempty"`

	// The ID of the HLB load balancer to attach this listener to. This cannot be changed once the listener is created - you must create a new listener to move it to a different load balancer.
	// +kubebuilder:validation:Optional
	LoadBalancerID *string `json:"loadBalancerId,omitempty" tf:"load_balancer_id,omitempty"`

	// When the load balancer `enable_cross_zone_load_balancing` is set to `avoid` (default), this factor determines how much traffic a single instance can receive relative to the average. For example, with a value of `1.1`, an instance can receive up to 110% of the average traffic. This helps optimize resource usage while maintaining zone isolation. Must be greater than or equal to 1.0. Applies to the target group - behavior is undefined if different values are assigned to different listeners with the same target group.
	// +kubebuilder:validation:Optional
	OverprovisioningFactor *float64 `json:"overprovisioningFactor,omitempty" tf:"overprovisioning_factor,omitempty"`

	// The port on which the load balancer is listening. Must be between 1 and 65535. Common ports:
	//
	// * 80 - HTTP
	// * 443 - HTTPS
	//
	// Note: The security groups associated with the load balancer must allow inbound traffic on this port.
	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// The protocol for connections from clients to the load balancer. Valid values:
	//
	// * `HTTP` - For unencrypted HTTP traffic
	// * `HTTPS` - For encrypted HTTPS traffic. When using HTTPS, you must also specify a `certificate_secrets_name`
	//
	// * `UDP` - For raw unencrypted UDP traffic
	//
	// The protocol cannot be changed after the listener is created - you must create a new listener to change protocols.
	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// The Amazon Resource Name (ARN) of the target group to route traffic to. The target group defines where traffic will be sent (the backend instances, IP addresses, or other resources) and how health checks are performed. The target group must be in the same region as the load balancer.
	// +kubebuilder:validation:Optional
	TargetGroupArn *string `json:"targetGroupArn,omitempty" tf:"target_group_arn,omitempty"`
}

// HeroLoadBalancerListenerAttachmentSpec defines the desired state of HeroLoadBalancerListenerAttachment
type HeroLoadBalancerListenerAttachmentSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     HeroLoadBalancerListenerAttachmentParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider HeroLoadBalancerListenerAttachmentInitParameters `json:"initProvider,omitempty"`
}

// HeroLoadBalancerListenerAttachmentStatus defines the observed state of HeroLoadBalancerListenerAttachment.
type HeroLoadBalancerListenerAttachmentStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        HeroLoadBalancerListenerAttachmentObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// HeroLoadBalancerListenerAttachment is the Schema for the HeroLoadBalancerListenerAttachments API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,zonehero-v2}
type HeroLoadBalancerListenerAttachment struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.loadBalancerId) || (has(self.initProvider) && has(self.initProvider.loadBalancerId))",message="spec.forProvider.loadBalancerId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.port) || (has(self.initProvider) && has(self.initProvider.port))",message="spec.forProvider.port is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.protocol) || (has(self.initProvider) && has(self.initProvider.protocol))",message="spec.forProvider.protocol is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.targetGroupArn) || (has(self.initProvider) && has(self.initProvider.targetGroupArn))",message="spec.forProvider.targetGroupArn is a required parameter"
	Spec   HeroLoadBalancerListenerAttachmentSpec   `json:"spec"`
	Status HeroLoadBalancerListenerAttachmentStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// HeroLoadBalancerListenerAttachmentList contains a list of HeroLoadBalancerListenerAttachments
type HeroLoadBalancerListenerAttachmentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []HeroLoadBalancerListenerAttachment `json:"items"`
}

// Repository type metadata.
var (
	HeroLoadBalancerListenerAttachment_Kind             = "HeroLoadBalancerListenerAttachment"
	HeroLoadBalancerListenerAttachment_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: HeroLoadBalancerListenerAttachment_Kind}.String()
	HeroLoadBalancerListenerAttachment_KindAPIVersion   = HeroLoadBalancerListenerAttachment_Kind + "." + CRDGroupVersion.String()
	HeroLoadBalancerListenerAttachment_GroupVersionKind = CRDGroupVersion.WithKind(HeroLoadBalancerListenerAttachment_Kind)
)

func init() {
	SchemeBuilder.Register(&HeroLoadBalancerListenerAttachment{}, &HeroLoadBalancerListenerAttachmentList{})
}
